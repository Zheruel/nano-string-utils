interface PerformanceResult {
  opsPerSecond: number;
  margin: number;
}

interface FunctionBenchmark {
  name: string;
  nano: PerformanceResult | null;
  lodash: PerformanceResult | null;
  esToolkit: PerformanceResult | null;
  winner: "nano" | "lodash" | "es-toolkit";
  speedup: number;
  nanoVsLodash?: number;
  nanoVsEsToolkit?: number;
}

interface PerformanceData {
  generated: string;
  totalFunctions: number;
  functions: FunctionBenchmark[];
  summary: {
    nanoWins: number;
    lodashWins: number;
    esToolkitWins: number;
    averageSpeedup: number;
  };
}

type SortField = "name" | "nano" | "winner" | "speedup";
type SortOrder = "asc" | "desc";

export async function initPerformanceViewer(): Promise<void> {
  const container = document.getElementById("performance-viewer");
  if (!container) {
    return;
  }

  container.innerHTML =
    '<div class="loading">Loading performance data...</div>';

  try {
    const baseUrl = import.meta.env.BASE_URL || "/";
    const url = `${baseUrl}performance-benchmarks.json`;

    const response = await fetch(url);
    if (!response.ok) {
      throw new Error(`Failed to load performance data: ${response.status}`);
    }

    const perfData: PerformanceData = await response.json();
    initViewer(container, perfData);
  } catch (error) {
    container.innerHTML = `
      <div class="error">
        <h2>Error Loading Performance Data</h2>
        <p>Could not load performance benchmark data. Please ensure the data has been generated by running:</p>
        <pre><code>npx tsx benchmarks/performance-benchmarks.ts</code></pre>
        <p class="error-detail">${error}</p>
      </div>
    `;
  }
}

function initViewer(container: HTMLElement, perfData: PerformanceData): void {
  let sortField: SortField = "name";
  let sortOrder: SortOrder = "asc";
  let filterText = "";

  const formatOps = (ops: number): string => {
    if (ops >= 1_000_000) {
      return `${(ops / 1_000_000).toFixed(2)}M ops/s`;
    } else if (ops >= 1_000) {
      return `${(ops / 1_000).toFixed(2)}K ops/s`;
    }
    return `${ops.toFixed(0)} ops/s`;
  };

  const formatMultiplier = (multiplier: number | undefined): string => {
    if (!multiplier) return "-";
    if (multiplier >= 1) {
      return `${multiplier.toFixed(2)}x faster`;
    } else {
      return `${(1 / multiplier).toFixed(2)}x slower`;
    }
  };

  const createControls = (): string => {
    return `
      <div class="bundle-summary">
        <div class="summary-stats">
          <div class="stat-card">
            <div class="stat-value">${perfData.totalFunctions}</div>
            <div class="stat-label">Functions Tested</div>
          </div>
          <div class="stat-card nano-win">
            <div class="stat-value">${perfData.summary.nanoWins}</div>
            <div class="stat-label">Nano Wins</div>
          </div>
          <div class="stat-card">
            <div class="stat-value">${perfData.summary.lodashWins}</div>
            <div class="stat-label">Lodash Wins</div>
          </div>
          <div class="stat-card">
            <div class="stat-value">${perfData.summary.esToolkitWins}</div>
            <div class="stat-label">es-toolkit Wins</div>
          </div>
          <div class="stat-card">
            <div class="stat-value">${perfData.summary.averageSpeedup.toFixed(
              2
            )}x</div>
            <div class="stat-label">Avg Speedup</div>
          </div>
        </div>
      </div>

      <div class="bundle-controls">
        <input
          type="text"
          id="perf-search"
          placeholder="Search functions..."
          class="search-input"
          value="${filterText}"
        />
        <label class="sort-label">Sort by:</label>
        <select id="perf-sort-field" class="sort-select">
          <option value="name" ${
            sortField === "name" ? "selected" : ""
          }>Name</option>
          <option value="nano" ${
            sortField === "nano" ? "selected" : ""
          }>Nano Performance</option>
          <option value="winner" ${
            sortField === "winner" ? "selected" : ""
          }>Winner</option>
          <option value="speedup" ${
            sortField === "speedup" ? "selected" : ""
          }>Speedup</option>
        </select>
        <button id="perf-sort-order" class="sort-button" data-order="${sortOrder}">
          ${sortOrder === "asc" ? "‚Üë" : "‚Üì"}
        </button>
      </div>
    `;
  };

  const createTable = (functions: FunctionBenchmark[]): string => {
    return `
      <div class="table-container">
        <table class="bundle-table">
          <thead>
            <tr>
              <th>
                <span class="th-text">Function</span>
              </th>
              <th>
                <span class="th-text">Nano</span>
              </th>
              <th>
                <span class="th-text">Lodash</span>
              </th>
              <th>
                <span class="th-text">ES-Toolkit</span>
              </th>
              <th>
                <span class="th-text">Winner</span>
              </th>
              <th>
                <span class="th-text">Comparison</span>
              </th>
            </tr>
          </thead>
          <tbody>
            ${functions
              .map((func) => {
                const nanoOps = func.nano?.opsPerSecond || 0;
                const lodashOps = func.lodash?.opsPerSecond || 0;
                const esToolkitOps = func.esToolkit?.opsPerSecond || 0;

                return `
                  <tr>
                    <td class="function-name">
                      <code>${func.name}</code>
                    </td>
                    <td class="size-cell ${
                      func.winner === "nano" ? "winner" : ""
                    }">
                      ${
                        func.nano
                          ? formatOps(nanoOps)
                          : '<span class="no-data">‚Äî</span>'
                      }
                    </td>
                    <td class="size-cell ${
                      func.winner === "lodash" ? "winner" : ""
                    }">
                      ${
                        func.lodash
                          ? formatOps(lodashOps)
                          : '<span class="no-data">‚Äî</span>'
                      }
                    </td>
                    <td class="size-cell ${
                      func.winner === "es-toolkit" ? "winner" : ""
                    }">
                      ${
                        func.esToolkit
                          ? formatOps(esToolkitOps)
                          : '<span class="no-data">‚Äî</span>'
                      }
                    </td>
                    <td class="winner-cell">
                      ${
                        func.winner === "nano"
                          ? '<span class="winner-nano">üèÜ nano</span>'
                          : func.winner === "lodash"
                          ? '<span class="winner-other">lodash</span>'
                          : '<span class="winner-other">es-toolkit</span>'
                      }
                    </td>
                    <td class="comparison-cell">
                      ${
                        func.nanoVsLodash
                          ? `<span class="comparison-text">vs lodash: ${formatMultiplier(
                              func.nanoVsLodash
                            )}</span><br>`
                          : ""
                      }
                      ${
                        func.nanoVsEsToolkit
                          ? `<span class="comparison-text">vs es-toolkit: ${formatMultiplier(
                              func.nanoVsEsToolkit
                            )}</span>`
                          : ""
                      }
                    </td>
                  </tr>
                `;
              })
              .join("")}
          </tbody>
        </table>
      </div>
    `;
  };

  const render = () => {
    let filteredFunctions = perfData.functions;

    // Apply filter
    if (filterText) {
      const query = filterText.toLowerCase();
      filteredFunctions = filteredFunctions.filter((func) =>
        func.name.toLowerCase().includes(query)
      );
    }

    // Apply sort
    filteredFunctions = [...filteredFunctions].sort((a, b) => {
      let aValue: string | number;
      let bValue: string | number;

      switch (sortField) {
        case "name":
          aValue = a.name;
          bValue = b.name;
          break;
        case "nano":
          aValue = a.nano?.opsPerSecond || 0;
          bValue = b.nano?.opsPerSecond || 0;
          break;
        case "winner":
          aValue = a.winner;
          bValue = b.winner;
          break;
        case "speedup":
          aValue = a.speedup;
          bValue = b.speedup;
          break;
        default:
          aValue = a.name;
          bValue = b.name;
      }

      let comparison = 0;
      if (typeof aValue === "string" && typeof bValue === "string") {
        comparison = aValue.localeCompare(bValue);
      } else {
        comparison = (aValue as number) - (bValue as number);
      }

      return sortOrder === "asc" ? comparison : -comparison;
    });

    container.innerHTML = `
      <div class="bundle-size-container">
        <h2>Performance Benchmarks</h2>
        <p class="intro">
          Comparing nano-string-utils performance against lodash and es-toolkit.
          Higher operations per second (ops/s) is better.
        </p>

        ${createControls()}
        ${createTable(filteredFunctions)}

        <div class="footer-note">
          <h3>Methodology</h3>
          <ul>
            <li>Benchmarks run using <a href="https://github.com/tinylibs/tinybench" target="_blank">tinybench</a> with 500ms warmup time</li>
            <li>Each function tested with realistic input data</li>
            <li>Results show operations per second (ops/s) - higher is better</li>
            <li>Speedup calculated as fastest vs slowest implementation</li>
            <li>All tests run on the same machine for fair comparison</li>
          </ul>
          <p class="generated-date">Generated: ${new Date(
            perfData.generated
          ).toLocaleString()}</p>
        </div>
      </div>
    `;

    attachEventHandlers();
  };

  const attachEventHandlers = () => {
    const searchInput = document.getElementById(
      "perf-search"
    ) as HTMLInputElement;
    const sortFieldSelect = document.getElementById(
      "perf-sort-field"
    ) as HTMLSelectElement;
    const sortOrderButton = document.getElementById(
      "perf-sort-order"
    ) as HTMLButtonElement;

    searchInput?.addEventListener("input", (e) => {
      filterText = (e.target as HTMLInputElement).value;
      render();
    });

    sortFieldSelect?.addEventListener("change", (e) => {
      sortField = (e.target as HTMLSelectElement).value as SortField;
      render();
    });

    sortOrderButton?.addEventListener("click", () => {
      sortOrder = sortOrder === "asc" ? "desc" : "asc";
      render();
    });
  };

  render();
}

interface PerformanceResult {
  opsPerSecond: number;
  margin: number;
}

interface FunctionBenchmark {
  name: string;
  nano: PerformanceResult | null;
  lodash: PerformanceResult | null;
  esToolkit: PerformanceResult | null;
  winner: "nano" | "lodash" | "es-toolkit";
  speedup: number;
  nanoVsLodash?: number;
  nanoVsEsToolkit?: number;
}

interface PerformanceData {
  generated: string;
  totalFunctions: number;
  functions: FunctionBenchmark[];
  summary: {
    nanoWins: number;
    lodashWins: number;
    esToolkitWins: number;
    averageSpeedup: number;
  };
}

type SortField = "name" | "nano" | "winner" | "speedup";
type SortOrder = "asc" | "desc";

export async function initPerformanceViewer(): Promise<void> {
  const container = document.getElementById("performance-viewer");
  if (!container) {
    return;
  }

  container.innerHTML =
    '<div class="loading">Loading performance data...</div>';

  try {
    const baseUrl = import.meta.env.BASE_URL || "/";
    const url = `${baseUrl}performance-benchmarks.json`;

    const response = await fetch(url);
    if (!response.ok) {
      throw new Error(`Failed to load performance data: ${response.status}`);
    }

    const perfData: PerformanceData = await response.json();
    initViewer(container, perfData);
  } catch (error) {
    container.innerHTML = `
      <div class="error">
        <h2>Error Loading Performance Data</h2>
        <p>Could not load performance benchmark data. Please ensure the data has been generated by running:</p>
        <pre><code>npx tsx benchmarks/performance-benchmarks.ts</code></pre>
        <p class="error-detail">${error}</p>
      </div>
    `;
  }
}

function initViewer(container: HTMLElement, perfData: PerformanceData): void {
  let sortField: SortField = "name";
  let sortOrder: SortOrder = "asc";
  let filterText = "";

  const formatOps = (ops: number): string => {
    if (ops >= 1_000_000) {
      return `${(ops / 1_000_000).toFixed(2)}M ops/s`;
    } else if (ops >= 1_000) {
      return `${(ops / 1_000).toFixed(2)}K ops/s`;
    }
    return `${ops.toFixed(0)} ops/s`;
  };

  const formatMultiplier = (multiplier: number | undefined): string => {
    if (!multiplier) return "-";
    if (multiplier >= 1) {
      return `${multiplier.toFixed(2)}x faster`;
    } else {
      return `${(1 / multiplier).toFixed(2)}x slower`;
    }
  };

  const createControls = (): string => {
    return `
      <div class="bundle-summary">
        <div class="summary-stats">
          <div class="stat-card">
            <div class="stat-value">${perfData.totalFunctions}</div>
            <div class="stat-label">Functions Tested</div>
          </div>
          <div class="stat-card nano-win">
            <div class="stat-value">${perfData.summary.nanoWins}</div>
            <div class="stat-label">Nano Wins</div>
          </div>
          <div class="stat-card">
            <div class="stat-value">${perfData.summary.lodashWins}</div>
            <div class="stat-label">Lodash Wins</div>
          </div>
          <div class="stat-card">
            <div class="stat-value">${perfData.summary.esToolkitWins}</div>
            <div class="stat-label">es-toolkit Wins</div>
          </div>
          <div class="stat-card">
            <div class="stat-value">${perfData.summary.averageSpeedup.toFixed(
              2
            )}x</div>
            <div class="stat-label">Avg Speedup</div>
          </div>
        </div>
      </div>

      <div class="bundle-controls">
        <input
          type="text"
          id="perf-search"
          placeholder="Search functions..."
          class="search-input"
          value="${filterText}"
        />
        <label class="sort-label">Sort by:</label>
        <select id="perf-sort-field" class="sort-select">
          <option value="name" ${
            sortField === "name" ? "selected" : ""
          }>Name</option>
          <option value="nano" ${
            sortField === "nano" ? "selected" : ""
          }>Nano Performance</option>
          <option value="winner" ${
            sortField === "winner" ? "selected" : ""
          }>Winner</option>
          <option value="speedup" ${
            sortField === "speedup" ? "selected" : ""
          }>Speedup</option>
        </select>
        <button id="perf-sort-order" class="sort-button" data-order="${sortOrder}">
          ${sortOrder === "asc" ? "‚Üë" : "‚Üì"}
        </button>
      </div>
    `;
  };

  const createTable = (): string => {
    let functions = [...perfData.functions];

    // Apply filter
    if (filterText) {
      functions = functions.filter((func) =>
        func.name.toLowerCase().includes(filterText.toLowerCase())
      );
    }

    // Show no results message if filtered list is empty
    if (functions.length === 0) {
      return `
        <div class="no-results">
          <div class="no-results-icon">üîç</div>
          <h3>No functions found</h3>
          <p>Try adjusting your search term "<strong>${filterText}</strong>"</p>
        </div>
      `;
    }

    // Sort functions
    functions.sort((a, b) => {
      let aValue: string | number;
      let bValue: string | number;

      switch (sortField) {
        case "name":
          aValue = a.name;
          bValue = b.name;
          break;
        case "nano":
          aValue = a.nano?.opsPerSecond || 0;
          bValue = b.nano?.opsPerSecond || 0;
          break;
        case "winner":
          aValue = a.winner;
          bValue = b.winner;
          break;
        case "speedup":
          aValue = a.speedup;
          bValue = b.speedup;
          break;
        default:
          aValue = a.name;
          bValue = b.name;
      }

      let comparison = 0;
      if (typeof aValue === "string" && typeof bValue === "string") {
        comparison = aValue.localeCompare(bValue);
      } else {
        comparison = (aValue as number) - (bValue as number);
      }

      return sortOrder === "asc" ? comparison : -comparison;
    });

    let tableHtml = `
      <div class="table-container">
        <table class="bundle-table">
          <thead>
            <tr>
              <th>
                <span class="th-text">Function</span>
              </th>
              <th>
                <span class="th-text">Nano</span>
              </th>
              <th>
                <span class="th-text">Lodash</span>
              </th>
              <th>
                <span class="th-text">ES-Toolkit</span>
              </th>
              <th>
                <span class="th-text">Winner</span>
              </th>
              <th>
                <span class="th-text">Comparison</span>
              </th>
            </tr>
          </thead>
          <tbody>
    `;

    for (const func of functions) {
      const nanoOps = func.nano?.opsPerSecond || 0;
      const lodashOps = func.lodash?.opsPerSecond || 0;
      const esToolkitOps = func.esToolkit?.opsPerSecond || 0;

      tableHtml += `
        <tr>
          <td class="function-name">
            <code>${func.name}</code>
          </td>
          <td class="size-cell ${func.winner === "nano" ? "winner" : ""}">
            ${func.nano ? formatOps(nanoOps) : '<span class="no-data">‚Äî</span>'}
          </td>
          <td class="size-cell ${func.winner === "lodash" ? "winner" : ""}">
            ${
              func.lodash
                ? formatOps(lodashOps)
                : '<span class="no-data">‚Äî</span>'
            }
          </td>
          <td class="size-cell ${func.winner === "es-toolkit" ? "winner" : ""}">
            ${
              func.esToolkit
                ? formatOps(esToolkitOps)
                : '<span class="no-data">‚Äî</span>'
            }
          </td>
          <td class="winner-cell">
            ${
              func.winner === "nano"
                ? '<span class="winner-nano">üèÜ nano</span>'
                : func.winner === "lodash"
                ? '<span class="winner-other">lodash</span>'
                : '<span class="winner-other">es-toolkit</span>'
            }
          </td>
          <td class="comparison-cell">
            ${
              func.nanoVsLodash
                ? `<span class="comparison-text">vs lodash: ${formatMultiplier(
                    func.nanoVsLodash
                  )}</span><br>`
                : ""
            }
            ${
              func.nanoVsEsToolkit
                ? `<span class="comparison-text">vs es-toolkit: ${formatMultiplier(
                    func.nanoVsEsToolkit
                  )}</span>`
                : ""
            }
          </td>
        </tr>
      `;
    }

    tableHtml += `
          </tbody>
        </table>
      </div>
    `;

    return tableHtml;
  };

  const updateTable = (): void => {
    const tableContainer = document.getElementById("perf-table-container");
    const sortOrderButton = document.getElementById(
      "perf-sort-order"
    ) as HTMLButtonElement;

    if (tableContainer) {
      tableContainer.innerHTML = createTable();
    }

    // Update sort button arrow
    if (sortOrderButton) {
      sortOrderButton.textContent = sortOrder === "asc" ? "‚Üë" : "‚Üì";
      sortOrderButton.setAttribute("data-order", sortOrder);
    }
  };

  const render = (): void => {
    const controlsHtml = createControls();

    const fullHtml = `
      <div class="bundle-size-container">
        <h2>Performance Benchmarks</h2>
        <p class="intro">
          Comparing nano-string-utils performance against lodash and es-toolkit.
          Higher operations per second (ops/s) is better.
        </p>

        ${controlsHtml}
        <div id="perf-table-container">${createTable()}</div>

        <div class="footer-note">
          <h3>Methodology</h3>
          <ul>
            <li>Benchmarks run using <a href="https://github.com/tinylibs/tinybench" target="_blank">tinybench</a> with 500ms warmup time</li>
            <li>Each function tested with realistic input data</li>
            <li>Results show operations per second (ops/s) - higher is better</li>
            <li>Speedup calculated as fastest vs slowest implementation</li>
            <li>All tests run on the same machine for fair comparison</li>
          </ul>
          <p class="generated-date">Generated: ${new Date(
            perfData.generated
          ).toLocaleString()}</p>
        </div>
      </div>
    `;

    container.innerHTML = fullHtml;

    // Add event listeners
    const searchInput = document.getElementById(
      "perf-search"
    ) as HTMLInputElement;
    const sortFieldSelect = document.getElementById(
      "perf-sort-field"
    ) as HTMLSelectElement;
    const sortOrderButton = document.getElementById(
      "perf-sort-order"
    ) as HTMLButtonElement;

    if (searchInput) {
      searchInput.addEventListener("input", (e) => {
        filterText = (e.target as HTMLInputElement).value;
        updateTable();
      });
    }

    if (sortFieldSelect) {
      sortFieldSelect.addEventListener("change", (e) => {
        sortField = (e.target as HTMLSelectElement).value as SortField;
        updateTable();
      });
    }

    if (sortOrderButton) {
      sortOrderButton.addEventListener("click", () => {
        sortOrder = sortOrder === "asc" ? "desc" : "asc";
        updateTable();
      });
    }
  };

  try {
    render();
  } catch (renderError) {
    container.innerHTML = `
      <div class="error">
        <h2>Error Rendering Performance Data</h2>
        <p>An error occurred while rendering the performance data.</p>
        <p class="error-detail">${renderError}</p>
      </div>
    `;
  }
}

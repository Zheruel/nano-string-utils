interface BundleFunction {
  name: string;
  nano: {
    bundled: { raw: number; gzip: number };
    treeShaken: { raw: number; gzip: number };
  };
  lodash: { raw: number; gzip: number } | null;
  esToolkit: { raw: number; gzip: number } | null;
  winner: string;
  percentSavings?: number;
}

interface BundleData {
  generated: string;
  totalFunctions: number;
  functions: BundleFunction[];
  summary: {
    totalNanoWins: number;
    totalEsToolkitWins: number;
    totalLodashWins: number;
    averageSavings: number;
    smallestFunction: string;
    largestFunction: string;
  };
}

type SortField = "name" | "size" | "savings" | "winner";
type SortOrder = "asc" | "desc";

export async function initBundleSizeViewer(): Promise<void> {
  const container = document.getElementById("bundle-size-viewer");
  if (!container) {
    return;
  }

  // Show loading state
  container.innerHTML =
    '<div class="loading">Loading bundle size data...</div>';

  try {
    // Fetch the bundle data
    // Use base URL for both dev and production
    const baseUrl = import.meta.env.BASE_URL || "/";
    const url = `${baseUrl}bundle-sizes.json`;

    const response = await fetch(url);
    if (!response.ok) {
      throw new Error(`Failed to load bundle data: ${response.status}`);
    }

    const bundleData: BundleData = await response.json();

    // Initialize the viewer with the data
    initViewer(container, bundleData);
  } catch (error) {
    container.innerHTML = `
      <div class="error">
        <h2>Error Loading Bundle Size Data</h2>
        <p>Could not load bundle size analysis data. Please ensure the data has been generated by running:</p>
        <pre><code>npm run bench:size</code></pre>
        <p class="error-detail">${error}</p>
      </div>
    `;
  }
}

function initViewer(container: HTMLElement, bundleData: BundleData): void {
  let sortField: SortField = "name";
  let sortOrder: SortOrder = "asc";
  let filterText = "";

  const formatBytes = (bytes: number): string => {
    if (bytes < 1024) return `${bytes}B`;
    const kb = bytes / 1024;
    return kb < 10 ? `${kb.toFixed(1)}KB` : `${Math.round(kb)}KB`;
  };

  const createControls = (): string => {
    return `
      <div class="bundle-summary">
        <p class="summary-line">
          Analyzing <strong>${bundleData.totalFunctions}</strong> functions ‚Ä¢
          <span class="success-text">nano wins ${
            bundleData.summary.totalNanoWins
          }/${bundleData.totalFunctions}</span> ‚Ä¢
          Average size reduction: <strong class="success-text">${Math.abs(
            bundleData.summary.averageSavings
          )}%</strong>
        </p>
      </div>
      <div class="bundle-controls">
        <input
          type="text"
          id="bundle-search"
          placeholder="Search functions..."
          value="${filterText}"
          class="search-input"
        />
      </div>
    `;
  };

  const createTable = (): string => {
    let functions = [...bundleData.functions] as BundleFunction[];

    // Apply filter
    if (filterText) {
      functions = functions.filter((f) =>
        f.name.toLowerCase().includes(filterText.toLowerCase())
      );
    }

    // Show no results message if filtered list is empty
    if (functions.length === 0) {
      return `
        <div class="no-results">
          <div class="no-results-icon">üîç</div>
          <h3>No functions found</h3>
          <p>Try adjusting your search term "<strong>${filterText}</strong>"</p>
        </div>
      `;
    }

    // Sort functions
    functions.sort((a, b) => {
      let comparison = 0;

      switch (sortField) {
        case "name":
          comparison = a.name.localeCompare(b.name);
          break;
        case "size":
          comparison =
            (a.nano.treeShaken.gzip || a.nano.bundled.gzip) -
            (b.nano.treeShaken.gzip || b.nano.bundled.gzip);
          break;
        case "savings":
          comparison = (a.percentSavings || 0) - (b.percentSavings || 0);
          break;
        case "winner":
          comparison = a.winner.localeCompare(b.winner);
          break;
      }

      return sortOrder === "asc" ? comparison : -comparison;
    });

    let tableHtml = `
      <div class="table-container">
        <table class="bundle-table">
          <thead>
            <tr>
              <th class="sortable ${
                sortField === "name" ? `sorted-${sortOrder}` : ""
              }" data-sort="name">
                <span class="th-text">Function</span>
              </th>
              <th class="sortable ${
                sortField === "size" ? `sorted-${sortOrder}` : ""
              }" data-sort="size">
                <span class="th-text">Nano Size</span>
                <div class="th-subtitle">(tree-shaken)</div>
              </th>
              <th>
                <span class="th-text">Lodash</span>
              </th>
              <th>
                <span class="th-text">ES-Toolkit</span>
              </th>
              <th class="sortable ${
                sortField === "winner" ? `sorted-${sortOrder}` : ""
              }" data-sort="winner">
                <span class="th-text">Winner</span>
              </th>
              <th class="sortable ${
                sortField === "savings" ? `sorted-${sortOrder}` : ""
              }" data-sort="savings">
                <span class="th-text">Savings</span>
              </th>
            </tr>
          </thead>
          <tbody>
    `;

    for (const func of functions) {
      const nanoSize = func.nano.treeShaken.gzip || func.nano.bundled.gzip;
      const lodashSize = func.lodash?.gzip;
      const esToolkitSize = func.esToolkit?.gzip;

      const savingsClass =
        func.percentSavings && func.percentSavings > 50
          ? "savings-high"
          : func.percentSavings && func.percentSavings > 0
          ? "savings-medium"
          : "";

      tableHtml += `
        <tr>
          <td class="function-name">
            <code>${func.name}</code>
          </td>
          <td class="size-cell">
            <span class="size-value">${formatBytes(nanoSize)}</span>
            ${
              func.nano.treeShaken.gzip !== func.nano.bundled.gzip
                ? `<span class="size-bundled">(${formatBytes(
                    func.nano.bundled.gzip
                  )} bundled)</span>`
                : ""
            }
          </td>
          <td class="size-cell">
            ${lodashSize ? formatBytes(lodashSize) : "-"}
          </td>
          <td class="size-cell">
            ${esToolkitSize ? formatBytes(esToolkitSize) : "-"}
          </td>
          <td class="winner-cell">
            ${
              func.winner === "nano"
                ? '<span class="winner-nano">üèÜ nano</span>'
                : func.winner === "es-toolkit"
                ? '<span class="winner-other">es-toolkit</span>'
                : '<span class="winner-other">‚Äî</span>'
            }
          </td>
          <td class="savings-cell">
            ${
              func.percentSavings !== undefined
                ? `<span class="${savingsClass}">${func.percentSavings}%</span>`
                : '<span class="no-data">‚Äî</span>'
            }
          </td>
        </tr>
      `;
    }

    tableHtml += `
          </tbody>
        </table>
      </div>
    `;

    return tableHtml;
  };

  const createSizeDistribution = (): string => {
    const functions = bundleData.functions as BundleFunction[];
    const sizes = functions.map(
      (f) => f.nano.treeShaken.gzip || f.nano.bundled.gzip
    );

    // Create size buckets
    const buckets = [
      { label: "< 500B", min: 0, max: 500, count: 0 },
      { label: "500B - 750B", min: 500, max: 750, count: 0 },
      { label: "750B - 1KB", min: 750, max: 1024, count: 0 },
      { label: "1KB - 1.5KB", min: 1024, max: 1536, count: 0 },
      { label: "> 1.5KB", min: 1536, max: Infinity, count: 0 },
    ];

    sizes.forEach((size) => {
      const bucket = buckets.find((b) => size >= b.min && size < b.max);
      if (bucket) bucket.count++;
    });

    const maxCount = Math.max(...buckets.map((b) => b.count));

    let chartHtml = `
      <div class="size-distribution">
        <h3>Size Distribution</h3>
        <div class="chart-container">
    `;

    for (const bucket of buckets) {
      const percentage = (bucket.count / functions.length) * 100;
      const barWidth = maxCount > 0 ? (bucket.count / maxCount) * 100 : 0;

      chartHtml += `
        <div class="chart-row">
          <div class="chart-label">${bucket.label}</div>
          <div class="chart-bar-container">
            <div class="chart-bar" style="width: ${barWidth}%"></div>
            <span class="chart-value">${bucket.count} (${Math.round(
        percentage
      )}%)</span>
          </div>
        </div>
      `;
    }

    chartHtml += `
        </div>
      </div>
    `;

    return chartHtml;
  };

  const updateTableAndChart = (): void => {
    const tableContainer = document.getElementById("table-container");
    const chartContainer = document.getElementById("chart-container");

    if (tableContainer) {
      tableContainer.innerHTML = createTable();
    }

    if (chartContainer) {
      chartContainer.innerHTML = createSizeDistribution();
    }

    // Re-attach sort listeners to new headers
    const sortableHeaders = container.querySelectorAll(".sortable");
    sortableHeaders.forEach((header) => {
      header.addEventListener("click", () => {
        const field = header.getAttribute("data-sort") as SortField;
        if (sortField === field) {
          sortOrder = sortOrder === "asc" ? "desc" : "asc";
        } else {
          sortField = field;
          sortOrder = "asc";
        }
        updateTableAndChart();
      });
    });
  };

  const render = (): void => {
    const controlsHtml = createControls();

    const fullHtml = `
      <div class="bundle-size-container">
        <h2>Bundle Size Analysis</h2>
        <p class="intro">
          Compare the bundle sizes of nano-string-utils functions with lodash and es-toolkit.
          All sizes are shown in gzipped format.
        </p>
        ${controlsHtml}
        <div id="table-container">${createTable()}</div>
        <div id="chart-container">${createSizeDistribution()}</div>
        <div class="footer-note">
          <p>
            <strong>Note:</strong> Tree-shaken sizes represent the cost of importing a single function.
            Bundled sizes show the cost when importing from the main index file.
          </p>
        </div>
      </div>
    `;

    container.innerHTML = fullHtml;

    // Add event listeners
    const searchInput = document.getElementById(
      "bundle-search"
    ) as HTMLInputElement;

    if (searchInput) {
      searchInput.addEventListener("input", (e) => {
        filterText = (e.target as HTMLInputElement).value;
        updateTableAndChart();
      });
    }

    // Initial sort listeners
    const sortableHeaders = container.querySelectorAll(".sortable");
    sortableHeaders.forEach((header) => {
      header.addEventListener("click", () => {
        const field = header.getAttribute("data-sort") as SortField;
        if (sortField === field) {
          sortOrder = sortOrder === "asc" ? "desc" : "asc";
        } else {
          sortField = field;
          sortOrder = "asc";
        }
        updateTableAndChart();
      });
    });
  };

  try {
    render();
  } catch (renderError) {
    container.innerHTML = `
      <div class="error">
        <h2>Error Rendering Bundle Sizes</h2>
        <p>An error occurred while rendering the bundle size data.</p>
        <p class="error-detail">${renderError}</p>
      </div>
    `;
  }
}
